# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T11:30:01+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, RootModel, SecretStr, conint, constr


class AccessDeniedException(RootModel[Any]):
    root: Any


class AccessKeyId(
    RootModel[constr(pattern=r'[\s\S]*\S[\s\S]*', min_length=1, max_length=255)]
):
    root: constr(pattern=r'[\s\S]*\S[\s\S]*', min_length=1, max_length=255)


class AliasString(
    RootModel[constr(pattern=r'^alias\/\S+', min_length=1, max_length=255)]
):
    root: constr(pattern=r'^alias\/\S+', min_length=1, max_length=255)


class ApiAccess(Enum):
    ENABLED = 'ENABLED'
    DISABLED = 'DISABLED'


class ApplicationPermission(Enum):
    CreateDataset = 'CreateDataset'
    ManageClusters = 'ManageClusters'
    ManageUsersAndGroups = 'ManageUsersAndGroups'
    ManageAttributeSets = 'ManageAttributeSets'
    ViewAuditData = 'ViewAuditData'
    AccessNotebooks = 'AccessNotebooks'
    GetTemporaryCredentials = 'GetTemporaryCredentials'


class ApplicationPermissionList(RootModel[List[ApplicationPermission]]):
    root: List[ApplicationPermission]


class Boolean(RootModel[bool]):
    root: bool = Field(..., description='Common Boolean data type')


class ChangeType(Enum):
    REPLACE = 'REPLACE'
    APPEND = 'APPEND'
    MODIFY = 'MODIFY'


class ChangesetArn(RootModel[str]):
    root: str = Field(..., description='Arn for a given Changeset')


class ChangesetId(RootModel[constr(min_length=1, max_length=26)]):
    root: constr(min_length=1, max_length=26) = Field(
        ..., description='ID used to identify a Changeset'
    )


class ClientToken(RootModel[constr(pattern=r'.*\S.*', min_length=1, max_length=128)]):
    root: constr(pattern=r'.*\S.*', min_length=1, max_length=128) = Field(
        ..., description='Idempotence Token for API operations'
    )


class ColumnDataType(Enum):
    STRING = 'STRING'
    CHAR = 'CHAR'
    INTEGER = 'INTEGER'
    TINYINT = 'TINYINT'
    SMALLINT = 'SMALLINT'
    BIGINT = 'BIGINT'
    FLOAT = 'FLOAT'
    DOUBLE = 'DOUBLE'
    DATE = 'DATE'
    DATETIME = 'DATETIME'
    BOOLEAN = 'BOOLEAN'
    BINARY = 'BINARY'


class ColumnDescription(RootModel[constr(pattern=r'[\s\S]*', max_length=512)]):
    root: constr(pattern=r'[\s\S]*', max_length=512) = Field(
        ..., description='Column Description'
    )


class ColumnName(RootModel[constr(pattern=r'.*\S.*', max_length=126)]):
    root: constr(pattern=r'.*\S.*', max_length=126) = Field(
        ..., description='Column Name'
    )


class ColumnNameList(RootModel[List[ColumnName]]):
    root: List[ColumnName] = Field(..., description='List of Column Names')


class ConflictException(RootModel[Any]):
    root: Any


class DataViewArn(RootModel[str]):
    root: str = Field(..., description='Arn of a DataView')


class DataViewDestinationType(RootModel[str]):
    root: str = Field(..., description='DataView Destination Type')


class DataViewId(RootModel[constr(min_length=1, max_length=26)]):
    root: constr(min_length=1, max_length=26) = Field(..., description='DataView ID')


class DataViewStatus(Enum):
    RUNNING = 'RUNNING'
    STARTING = 'STARTING'
    FAILED = 'FAILED'
    CANCELLED = 'CANCELLED'
    TIMEOUT = 'TIMEOUT'
    SUCCESS = 'SUCCESS'
    PENDING = 'PENDING'
    FAILED_CLEANUP_FAILED = 'FAILED_CLEANUP_FAILED'


class DatasetArn(RootModel[str]):
    root: str = Field(..., description='Arn of a Dataset')


class DatasetDescription(RootModel[constr(pattern=r'[\s\S]*', max_length=1000)]):
    root: constr(pattern=r'[\s\S]*', max_length=1000) = Field(
        ..., description='Description of a dataset'
    )


class DatasetId(RootModel[constr(min_length=1, max_length=26)]):
    root: constr(min_length=1, max_length=26) = Field(
        ..., description='ID for a given Dataset'
    )


class DatasetKind(Enum):
    TABULAR = 'TABULAR'
    NON_TABULAR = 'NON_TABULAR'


class DatasetStatus(Enum):
    PENDING = 'PENDING'
    FAILED = 'FAILED'
    SUCCESS = 'SUCCESS'
    RUNNING = 'RUNNING'


class DatasetTitle(RootModel[constr(pattern=r'.*\S.*', min_length=1, max_length=255)]):
    root: constr(pattern=r'.*\S.*', min_length=1, max_length=255) = Field(
        ..., description='Title for a given Dataset'
    )


class DeleteDatasetRequest(BaseModel):
    pass


class DeleteDatasetResponse(BaseModel):
    datasetId: Optional[DatasetId] = None


class DeletePermissionGroupRequest(BaseModel):
    pass


class DisableUserRequest(BaseModel):
    clientToken: Optional[ClientToken] = None


class DisassociateUserFromPermissionGroupRequest(BaseModel):
    pass


class Email(RootModel[SecretStr]):
    root: SecretStr


class EnableUserRequest(BaseModel):
    clientToken: Optional[ClientToken] = None


class ErrorCategory(Enum):
    VALIDATION = 'VALIDATION'
    SERVICE_QUOTA_EXCEEDED = 'SERVICE_QUOTA_EXCEEDED'
    ACCESS_DENIED = 'ACCESS_DENIED'
    RESOURCE_NOT_FOUND = 'RESOURCE_NOT_FOUND'
    THROTTLING = 'THROTTLING'
    INTERNAL_SERVICE_EXCEPTION = 'INTERNAL_SERVICE_EXCEPTION'
    CANCELLED = 'CANCELLED'
    USER_RECOVERABLE = 'USER_RECOVERABLE'


class ErrorMessage(RootModel[constr(max_length=1000)]):
    root: constr(max_length=1000) = Field(..., description='Changeset Error Message')


class ExportFileFormat(Enum):
    PARQUET = 'PARQUET'
    DELIMITED_TEXT = 'DELIMITED_TEXT'


class FirstName(RootModel[SecretStr]):
    root: SecretStr


class GetChangesetRequest(BaseModel):
    pass


class GetDataViewRequest(BaseModel):
    pass


class GetDatasetRequest(BaseModel):
    pass


class GetExternalDataViewAccessDetailsRequest(BaseModel):
    pass


class GetPermissionGroupRequest(BaseModel):
    pass


class GetProgrammaticAccessCredentialsRequest(BaseModel):
    pass


class GetUserRequest(BaseModel):
    pass


class IdType(RootModel[constr(min_length=1, max_length=26)]):
    root: constr(min_length=1, max_length=26)


class IngestionStatus(Enum):
    PENDING = 'PENDING'
    FAILED = 'FAILED'
    SUCCESS = 'SUCCESS'
    RUNNING = 'RUNNING'
    STOP_REQUESTED = 'STOP_REQUESTED'


class InternalServerException(RootModel[Any]):
    root: Any


class LastName(RootModel[SecretStr]):
    root: SecretStr


class LimitExceededException(RootModel[Any]):
    root: Any


class ListChangesetsRequest(BaseModel):
    pass


class ListDataViewsRequest(BaseModel):
    pass


class ListDatasetsRequest(BaseModel):
    pass


class ListPermissionGroupsByUserRequest(BaseModel):
    pass


class ListPermissionGroupsRequest(BaseModel):
    pass


class ListUsersByPermissionGroupRequest(BaseModel):
    pass


class ListUsersRequest(BaseModel):
    pass


class OwnerName(RootModel[constr(pattern=r'.*\S.*', min_length=1, max_length=250)]):
    root: constr(pattern=r'.*\S.*', min_length=1, max_length=250) = Field(
        ..., description='1 - 250 character String'
    )


class PaginationToken(RootModel[str]):
    root: str


class Password(RootModel[SecretStr]):
    root: SecretStr


class PermissionGroupDescription(RootModel[SecretStr]):
    root: SecretStr


class PermissionGroupId(
    RootModel[constr(pattern=r'.*\S.*', min_length=1, max_length=26)]
):
    root: constr(pattern=r'.*\S.*', min_length=1, max_length=26)


class PermissionGroupMembershipStatus(Enum):
    ADDITION_IN_PROGRESS = 'ADDITION_IN_PROGRESS'
    ADDITION_SUCCESS = 'ADDITION_SUCCESS'
    REMOVAL_IN_PROGRESS = 'REMOVAL_IN_PROGRESS'


class PermissionGroupName(RootModel[SecretStr]):
    root: SecretStr


class PhoneNumber(
    RootModel[
        constr(
            pattern=r'^[\+0-9\#\,\(][\+0-9\-\.\/\(\)\,\#\s]+$',
            min_length=10,
            max_length=20,
        )
    ]
):
    root: constr(
        pattern=r'^[\+0-9\#\,\(][\+0-9\-\.\/\(\)\,\#\s]+$', min_length=10, max_length=20
    ) = Field(..., description='PhoneNumber of Dataset Owner')


class ResetUserPasswordRequest(BaseModel):
    clientToken: Optional[ClientToken] = None


class ResourceNotFoundException(RootModel[Any]):
    root: Any


class ResultLimit(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class RoleArn(
    RootModel[
        constr(
            pattern=r'^arn:aws[a-z\-]*:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+$',
            min_length=20,
            max_length=2048,
        )
    ]
):
    root: constr(
        pattern=r'^arn:aws[a-z\-]*:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+$',
        min_length=20,
        max_length=2048,
    )


class S3BucketName(RootModel[constr(pattern=r'^.*\S.*$', min_length=1, max_length=63)]):
    root: constr(pattern=r'^.*\S.*$', min_length=1, max_length=63)


class S3Key(RootModel[constr(pattern=r'^.*\S.*$', min_length=1, max_length=1024)]):
    root: constr(pattern=r'^.*\S.*$', min_length=1, max_length=1024)


class S3Location(BaseModel):
    bucket: S3BucketName
    key: S3Key


class SecretAccessKey(RootModel[SecretStr]):
    root: SecretStr


class SessionDuration(RootModel[conint(ge=60, le=720)]):
    root: conint(ge=60, le=720)


class SessionToken(RootModel[SecretStr]):
    root: SecretStr


class StatusCode(RootModel[int]):
    root: int


class StringMapKey(RootModel[constr(pattern=r'[\s\S]*\S[\s\S]*', max_length=128)]):
    root: constr(pattern=r'[\s\S]*\S[\s\S]*', max_length=128)


class StringMapValue(RootModel[constr(pattern=r'[\s\S]*\S[\s\S]*', max_length=1000)]):
    root: constr(pattern=r'[\s\S]*\S[\s\S]*', max_length=1000)


class StringValueLength1to250(
    RootModel[constr(pattern=r'[\s\S]*\S[\s\S]*', min_length=1, max_length=250)]
):
    root: constr(pattern=r'[\s\S]*\S[\s\S]*', min_length=1, max_length=250) = Field(
        ..., description='1 - 250 character String'
    )


class StringValueLength1to255(
    RootModel[constr(pattern=r'[\s\S]*\S[\s\S]*', min_length=1, max_length=255)]
):
    root: constr(pattern=r'[\s\S]*\S[\s\S]*', min_length=1, max_length=255) = Field(
        ..., description='1 - 255 character String'
    )


class ThrottlingException(RootModel[Any]):
    root: Any


class TimestampEpoch(RootModel[int]):
    root: int = Field(..., description='Milliseconds since UTC epoch')


class UpdateChangesetResponse(BaseModel):
    changesetId: Optional[ChangesetId] = None
    datasetId: Optional[DatasetId] = None


class UpdateDatasetResponse(BaseModel):
    datasetId: Optional[DatasetId] = None


class UpdatePermissionGroupRequest(BaseModel):
    applicationPermissions: Optional[ApplicationPermissionList] = None
    clientToken: Optional[ClientToken] = None
    description: Optional[PermissionGroupDescription] = None
    name: Optional[PermissionGroupName] = None


class UpdatePermissionGroupResponse(BaseModel):
    permissionGroupId: Optional[PermissionGroupId] = None


class UserId(RootModel[constr(pattern=r'.*\S.*', min_length=1, max_length=26)]):
    root: constr(pattern=r'.*\S.*', min_length=1, max_length=26)


class UserStatus(Enum):
    CREATING = 'CREATING'
    ENABLED = 'ENABLED'
    DISABLED = 'DISABLED'


class UserType(Enum):
    SUPER_USER = 'SUPER_USER'
    APP_USER = 'APP_USER'


class ValidationException(RootModel[Any]):
    root: Any


class LocationType(Enum):
    INGESTION = 'INGESTION'
    SAGEMAKER = 'SAGEMAKER'


class StringValueLength1to1024(
    RootModel[constr(pattern=r'.*\S.*', min_length=1, max_length=1024)]
):
    root: constr(pattern=r'.*\S.*', min_length=1, max_length=1024)


class StringValueLength1to255Model(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class StringValueLength1to63(
    RootModel[constr(pattern=r'.*\S.*', min_length=1, max_length=63)]
):
    root: constr(pattern=r'.*\S.*', min_length=1, max_length=63)


class StringValueMaxLength1000(RootModel[constr(max_length=1000)]):
    root: constr(max_length=1000)


class DatasetsDatasetIdChangesetsv2PostRequest(BaseModel):
    changeType: ChangeType = Field(
        ...,
        description='Indicates how the given change will be applied to the dataset.',
    )
    clientToken: Optional[constr(pattern=r'.*\S.*', min_length=1, max_length=128)] = (
        Field(None, description='Idempotence Token for API operations')
    )
    formatParams: Dict[str, StringMapValue] = Field(
        ..., description='Format Parameters of a Changeset'
    )
    sourceParams: Dict[str, StringMapValue] = Field(
        ..., description='Source Parameters of a Changeset'
    )


class DatasetsDatasetIdChangesetsv2ChangesetIdPutRequest(BaseModel):
    clientToken: Optional[constr(pattern=r'.*\S.*', min_length=1, max_length=128)] = (
        Field(None, description='Idempotence Token for API operations')
    )
    formatParams: Dict[str, StringMapValue] = Field(
        ..., description='Format Parameters of a Changeset'
    )
    sourceParams: Dict[str, StringMapValue] = Field(
        ..., description='Source Parameters of a Changeset'
    )


class Kind(Enum):
    TABULAR = 'TABULAR'
    NON_TABULAR = 'NON_TABULAR'


class OwnerInfo(BaseModel):
    email: Optional[Email] = None
    name: Optional[OwnerName] = None
    phoneNumber: Optional[PhoneNumber] = None


class PermissionGroupPostRequest(BaseModel):
    applicationPermissions: List[ApplicationPermission] = Field(
        ...,
        description="<p>The option to indicate FinSpace application permissions that are granted to a specific group.</p> <important> <p>When assigning application permissions, be aware that the permission <code>ManageUsersAndGroups</code> allows users to grant themselves or others access to any functionality in their FinSpace environment's application. It should only be granted to trusted users.</p> </important> <ul> <li> <p> <code>CreateDataset</code> – Group members can create new datasets.</p> </li> <li> <p> <code>ManageClusters</code> – Group members can manage Apache Spark clusters from FinSpace notebooks.</p> </li> <li> <p> <code>ManageUsersAndGroups</code> – Group members can manage users and permission groups. This is a privileged permission that allows users to grant themselves or others access to any functionality in the application. It should only be granted to trusted users.</p> </li> <li> <p> <code>ManageAttributeSets</code> – Group members can manage attribute sets.</p> </li> <li> <p> <code>ViewAuditData</code> – Group members can view audit data.</p> </li> <li> <p> <code>AccessNotebooks</code> – Group members will have access to FinSpace notebooks.</p> </li> <li> <p> <code>GetTemporaryCredentials</code> – Group members can get temporary API credentials.</p> </li> </ul>",
    )
    clientToken: Optional[constr(pattern=r'.*\S.*', min_length=1, max_length=128)] = (
        Field(None, description='Idempotence Token for API operations')
    )
    description: Optional[SecretStr] = Field(
        None, description='A brief description for the permission group.'
    )
    name: SecretStr = Field(..., description='The name of the permission group.')


class PermissionGroupPermissionGroupIdPutRequest(BaseModel):
    applicationPermissions: Optional[List[ApplicationPermission]] = Field(
        None,
        description="<p>The permissions that are granted to a specific group for accessing the FinSpace application.</p> <important> <p>When assigning application permissions, be aware that the permission <code>ManageUsersAndGroups</code> allows users to grant themselves or others access to any functionality in their FinSpace environment's application. It should only be granted to trusted users.</p> </important> <ul> <li> <p> <code>CreateDataset</code> – Group members can create new datasets.</p> </li> <li> <p> <code>ManageClusters</code> – Group members can manage Apache Spark clusters from FinSpace notebooks.</p> </li> <li> <p> <code>ManageUsersAndGroups</code> – Group members can manage users and permission groups. This is a privileged permission that allows users to grant themselves or others access to any functionality in the application. It should only be granted to trusted users.</p> </li> <li> <p> <code>ManageAttributeSets</code> – Group members can manage attribute sets.</p> </li> <li> <p> <code>ViewAuditData</code> – Group members can view audit data.</p> </li> <li> <p> <code>AccessNotebooks</code> – Group members will have access to FinSpace notebooks.</p> </li> <li> <p> <code>GetTemporaryCredentials</code> – Group members can get temporary API credentials.</p> </li> </ul>",
    )
    clientToken: Optional[constr(pattern=r'.*\S.*', min_length=1, max_length=128)] = (
        Field(None, description='Idempotence Token for API operations')
    )
    description: Optional[SecretStr] = Field(
        None, description='A brief description for the permission group.'
    )
    name: Optional[SecretStr] = Field(
        None, description='The name of the permission group.'
    )


class PermissionGroupPermissionGroupIdUsersUserIdPostRequest(BaseModel):
    clientToken: Optional[constr(pattern=r'.*\S.*', min_length=1, max_length=128)] = (
        Field(None, description='Idempotence Token for API operations')
    )


class Type(Enum):
    SUPER_USER = 'SUPER_USER'
    APP_USER = 'APP_USER'


class UserPostRequest(BaseModel):
    ApiAccess_1: Optional[ApiAccess] = Field(
        None,
        alias='ApiAccess',
        description='<p>The option to indicate whether the user can use the <code>GetProgrammaticAccessCredentials</code> API to obtain credentials that can then be used to access other FinSpace Data API operations.</p> <ul> <li> <p> <code>ENABLED</code> – The user has permissions to use the APIs.</p> </li> <li> <p> <code>DISABLED</code> – The user does not have permissions to use any APIs.</p> </li> </ul>',
    )
    apiAccessPrincipalArn: Optional[
        constr(
            pattern=r'^arn:aws[a-z\-]*:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+$',
            min_length=20,
            max_length=2048,
        )
    ] = Field(
        None,
        description='The ARN identifier of an AWS user or role that is allowed to call the <code>GetProgrammaticAccessCredentials</code> API to obtain a credentials token for a specific FinSpace user. This must be an IAM role within your FinSpace account.',
    )
    clientToken: Optional[constr(pattern=r'.*\S.*', min_length=1, max_length=128)] = (
        Field(None, description='Idempotence Token for API operations')
    )
    emailAddress: SecretStr = Field(
        ...,
        description="The email address of the user that you want to register. The email address serves as a uniquer identifier for each user and cannot be changed after it's created.",
    )
    firstName: Optional[SecretStr] = Field(
        None, description='The first name of the user that you want to register.'
    )
    lastName: Optional[SecretStr] = Field(
        None, description='The last name of the user that you want to register.'
    )
    type: Type = Field(
        ...,
        description='<p>The option to indicate the type of user. Use one of the following options to specify this parameter:</p> <ul> <li> <p> <code>SUPER_USER</code> – A user with permission to all the functionality and data in FinSpace.</p> </li> <li> <p> <code>APP_USER</code> – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.</p> </li> </ul>',
    )


class UserUserIdPutRequest(BaseModel):
    apiAccess: Optional[ApiAccess] = Field(
        None,
        description='<p>The option to indicate whether the user can use the <code>GetProgrammaticAccessCredentials</code> API to obtain credentials that can then be used to access other FinSpace Data API operations.</p> <ul> <li> <p> <code>ENABLED</code> – The user has permissions to use the APIs.</p> </li> <li> <p> <code>DISABLED</code> – The user does not have permissions to use any APIs.</p> </li> </ul>',
    )
    apiAccessPrincipalArn: Optional[
        constr(
            pattern=r'^arn:aws[a-z\-]*:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+$',
            min_length=20,
            max_length=2048,
        )
    ] = Field(
        None,
        description='The ARN identifier of an AWS user or role that is allowed to call the <code>GetProgrammaticAccessCredentials</code> API to obtain a credentials token for a specific FinSpace user. This must be an IAM role within your FinSpace account.',
    )
    clientToken: Optional[constr(pattern=r'.*\S.*', min_length=1, max_length=128)] = (
        Field(None, description='Idempotence Token for API operations')
    )
    firstName: Optional[SecretStr] = Field(
        None, description='The first name of the user.'
    )
    lastName: Optional[SecretStr] = Field(
        None, description='The last name of the user.'
    )
    type: Optional[Type] = Field(
        None,
        description='<p>The option to indicate the type of user.</p> <ul> <li> <p> <code>SUPER_USER</code>– A user with permission to all the functionality and data in FinSpace.</p> </li> <li> <p> <code>APP_USER</code> – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.</p> </li> </ul>',
    )


class UserUserIdDisablePostRequest(BaseModel):
    clientToken: Optional[constr(pattern=r'.*\S.*', min_length=1, max_length=128)] = (
        Field(None, description='Idempotence Token for API operations')
    )


class UserUserIdEnablePostRequest(BaseModel):
    clientToken: Optional[constr(pattern=r'.*\S.*', min_length=1, max_length=128)] = (
        Field(None, description='Idempotence Token for API operations')
    )


class UserUserIdPasswordPostRequest(BaseModel):
    clientToken: Optional[constr(pattern=r'.*\S.*', min_length=1, max_length=128)] = (
        Field(None, description='Idempotence Token for API operations')
    )


class WorkingLocationV1PostRequest(BaseModel):
    locationType: Optional[LocationType] = Field(
        None,
        description='<p>Specify the type of the working location.</p> <ul> <li> <p> <code>SAGEMAKER</code> – Use the Amazon S3 location as a temporary location to store data content when working with FinSpace Notebooks that run on SageMaker studio.</p> </li> <li> <p> <code>INGESTION</code> – Use the Amazon S3 location as a staging location to copy your data content and then use the location with the Changeset creation operation.</p> </li> </ul>',
    )


class AssociateUserToPermissionGroupRequest(BaseModel):
    clientToken: Optional[ClientToken] = None


class AssociateUserToPermissionGroupResponse(BaseModel):
    statusCode: Optional[StatusCode] = None


class AwsCredentials(BaseModel):
    accessKeyId: Optional[AccessKeyId] = None
    expiration: Optional[TimestampEpoch] = None
    secretAccessKey: Optional[SecretAccessKey] = None
    sessionToken: Optional[SessionToken] = None


class ChangesetErrorInfo(BaseModel):
    errorCategory: Optional[ErrorCategory] = None
    errorMessage: Optional[ErrorMessage] = None


class ColumnDefinition(BaseModel):
    columnDescription: Optional[ColumnDescription] = None
    columnName: Optional[ColumnName] = None
    dataType: Optional[ColumnDataType] = None


class ColumnList(RootModel[List[ColumnDefinition]]):
    root: List[ColumnDefinition] = Field(..., description='List of Column Definitions')


class CreateChangesetResponse(BaseModel):
    changesetId: Optional[ChangesetId] = None
    datasetId: Optional[DatasetId] = None


class CreateDataViewResponse(BaseModel):
    dataViewId: Optional[DataViewId] = None
    datasetId: Optional[DatasetId] = None


class CreateDatasetResponse(BaseModel):
    datasetId: Optional[DatasetId] = None


class CreatePermissionGroupRequest(BaseModel):
    applicationPermissions: ApplicationPermissionList
    clientToken: Optional[ClientToken] = None
    description: Optional[PermissionGroupDescription] = None
    name: PermissionGroupName


class CreatePermissionGroupResponse(BaseModel):
    permissionGroupId: Optional[PermissionGroupId] = None


class CreateUserRequest(BaseModel):
    ApiAccess_1: Optional[ApiAccess] = Field(None, alias='ApiAccess')
    apiAccessPrincipalArn: Optional[RoleArn] = None
    clientToken: Optional[ClientToken] = None
    emailAddress: Email
    firstName: Optional[FirstName] = None
    lastName: Optional[LastName] = None
    type: UserType


class CreateUserResponse(BaseModel):
    userId: Optional[UserId] = None


class Credentials(BaseModel):
    accessKeyId: Optional[StringValueLength1to255Model] = None
    secretAccessKey: Optional[StringValueMaxLength1000] = None
    sessionToken: Optional[StringValueMaxLength1000] = None


class DataViewErrorInfo(BaseModel):
    errorCategory: Optional[ErrorCategory] = None
    errorMessage: Optional[ErrorMessage] = None


class DatasetOwnerInfo(BaseModel):
    email: Optional[Email] = None
    name: Optional[OwnerName] = None
    phoneNumber: Optional[PhoneNumber] = None


class DeletePermissionGroupResponse(BaseModel):
    permissionGroupId: Optional[PermissionGroupId] = None


class DisableUserResponse(BaseModel):
    userId: Optional[UserId] = None


class DisassociateUserFromPermissionGroupResponse(BaseModel):
    statusCode: Optional[StatusCode] = None


class EnableUserResponse(BaseModel):
    userId: Optional[UserId] = None


class FormatParams(RootModel[Optional[Dict[str, StringMapValue]]]):
    root: Optional[Dict[str, StringMapValue]] = None


class GetExternalDataViewAccessDetailsResponse(BaseModel):
    credentials: Optional[AwsCredentials] = None
    s3Location: Optional[S3Location] = None


class GetProgrammaticAccessCredentialsResponse(BaseModel):
    credentials: Optional[Credentials] = None
    durationInMinutes: Optional[SessionDuration] = None


class GetUserResponse(BaseModel):
    apiAccess: Optional[ApiAccess] = None
    apiAccessPrincipalArn: Optional[RoleArn] = None
    createTime: Optional[TimestampEpoch] = None
    emailAddress: Optional[Email] = None
    firstName: Optional[FirstName] = None
    lastDisabledTime: Optional[TimestampEpoch] = None
    lastEnabledTime: Optional[TimestampEpoch] = None
    lastLoginTime: Optional[TimestampEpoch] = None
    lastModifiedTime: Optional[TimestampEpoch] = None
    lastName: Optional[LastName] = None
    status: Optional[UserStatus] = None
    type: Optional[UserType] = None
    userId: Optional[UserId] = None


class GetWorkingLocationRequest(BaseModel):
    locationType: Optional[LocationType] = None


class GetWorkingLocationResponse(BaseModel):
    s3Bucket: Optional[StringValueLength1to63] = None
    s3Path: Optional[StringValueLength1to1024] = None
    s3Uri: Optional[StringValueLength1to1024] = None


class PartitionColumnList(RootModel[List[StringValueLength1to255]]):
    root: List[StringValueLength1to255] = Field(
        ..., description='DataView Partition Column List'
    )


class PermissionGroup(BaseModel):
    applicationPermissions: Optional[ApplicationPermissionList] = None
    createTime: Optional[TimestampEpoch] = None
    description: Optional[PermissionGroupDescription] = None
    lastModifiedTime: Optional[TimestampEpoch] = None
    membershipStatus: Optional[PermissionGroupMembershipStatus] = None
    name: Optional[PermissionGroupName] = None
    permissionGroupId: Optional[PermissionGroupId] = None


class PermissionGroupByUser(BaseModel):
    membershipStatus: Optional[PermissionGroupMembershipStatus] = None
    name: Optional[PermissionGroupName] = None
    permissionGroupId: Optional[PermissionGroupId] = None


class PermissionGroupByUserList(RootModel[List[PermissionGroupByUser]]):
    root: List[PermissionGroupByUser]


class PermissionGroupList(RootModel[List[PermissionGroup]]):
    root: List[PermissionGroup]


class ResetUserPasswordResponse(BaseModel):
    temporaryPassword: Optional[Password] = None
    userId: Optional[UserId] = None


class ResourcePermission(BaseModel):
    permission: Optional[StringValueLength1to250] = None


class ResourcePermissionsList(RootModel[List[ResourcePermission]]):
    root: List[ResourcePermission] = Field(
        ..., description='List of Resource Permissions'
    )


class S3DestinationFormatOptions(RootModel[Optional[Dict[str, StringMapValue]]]):
    root: Optional[Dict[str, StringMapValue]] = None


class SchemaDefinition(BaseModel):
    columns: Optional[ColumnList] = None
    primaryKeyColumns: Optional[ColumnNameList] = None


class SchemaUnion(BaseModel):
    tabularSchemaConfig: Optional[SchemaDefinition] = None


class SortColumnList(RootModel[List[StringValueLength1to255]]):
    root: List[StringValueLength1to255] = Field(
        ..., description='DataView Sort Column List'
    )


class SourceParams(RootModel[Optional[Dict[str, StringMapValue]]]):
    root: Optional[Dict[str, StringMapValue]] = None


class UpdateChangesetRequest(BaseModel):
    clientToken: Optional[ClientToken] = None
    formatParams: FormatParams
    sourceParams: SourceParams


class UpdateDatasetRequest(BaseModel):
    alias: Optional[AliasString] = None
    clientToken: Optional[ClientToken] = None
    datasetDescription: Optional[DatasetDescription] = None
    datasetTitle: DatasetTitle
    kind: DatasetKind
    schemaDefinition: Optional[SchemaUnion] = None


class UpdateUserRequest(BaseModel):
    apiAccess: Optional[ApiAccess] = None
    apiAccessPrincipalArn: Optional[RoleArn] = None
    clientToken: Optional[ClientToken] = None
    firstName: Optional[FirstName] = None
    lastName: Optional[LastName] = None
    type: Optional[UserType] = None


class UpdateUserResponse(BaseModel):
    userId: Optional[UserId] = None


class User(BaseModel):
    apiAccess: Optional[ApiAccess] = None
    apiAccessPrincipalArn: Optional[RoleArn] = None
    createTime: Optional[TimestampEpoch] = None
    emailAddress: Optional[Email] = None
    firstName: Optional[FirstName] = None
    lastDisabledTime: Optional[TimestampEpoch] = None
    lastEnabledTime: Optional[TimestampEpoch] = None
    lastLoginTime: Optional[TimestampEpoch] = None
    lastModifiedTime: Optional[TimestampEpoch] = None
    lastName: Optional[LastName] = None
    status: Optional[UserStatus] = None
    type: Optional[UserType] = None
    userId: Optional[UserId] = None


class UserByPermissionGroup(BaseModel):
    apiAccess: Optional[ApiAccess] = None
    apiAccessPrincipalArn: Optional[RoleArn] = None
    emailAddress: Optional[Email] = None
    firstName: Optional[FirstName] = None
    lastName: Optional[LastName] = None
    membershipStatus: Optional[PermissionGroupMembershipStatus] = None
    status: Optional[UserStatus] = None
    type: Optional[UserType] = None
    userId: Optional[UserId] = None


class UserByPermissionGroupList(RootModel[List[UserByPermissionGroup]]):
    root: List[UserByPermissionGroup]


class UserList(RootModel[List[User]]):
    root: List[User]


class DestinationTypeParams(BaseModel):
    destinationType: Optional[DataViewDestinationType] = None
    s3DestinationExportFileFormat: Optional[ExportFileFormat] = None
    s3DestinationExportFileFormatOptions: Optional[S3DestinationFormatOptions] = None


class DatasetsDatasetIdDataviewsv2PostRequest(BaseModel):
    asOfTimestamp: Optional[int] = Field(
        None, description='Milliseconds since UTC epoch'
    )
    autoUpdate: Optional[bool] = Field(None, description='Common Boolean data type')
    clientToken: Optional[constr(pattern=r'.*\S.*', min_length=1, max_length=128)] = (
        Field(None, description='Idempotence Token for API operations')
    )
    destinationTypeParams: DestinationTypeParams = Field(
        ..., description='Structure for the Dataview destination type parameters.'
    )
    partitionColumns: Optional[List[StringValueLength1to255]] = Field(
        None, description='DataView Partition Column List'
    )
    sortColumns: Optional[List[StringValueLength1to255]] = Field(
        None, description='DataView Sort Column List'
    )


class PermissionGroupParams(BaseModel):
    datasetPermissions: Optional[ResourcePermissionsList] = None
    permissionGroupId: Optional[PermissionGroupId] = None


class SchemaDefinition1(BaseModel):
    tabularSchemaConfig: Optional[SchemaDefinition] = None


class Datasetsv2PostRequest(BaseModel):
    alias: Optional[constr(pattern=r'^alias\/\S+', min_length=1, max_length=255)] = (
        Field(None, description='The unique resource identifier for a Dataset.')
    )
    clientToken: Optional[constr(pattern=r'.*\S.*', min_length=1, max_length=128)] = (
        Field(None, description='Idempotence Token for API operations')
    )
    datasetDescription: Optional[constr(pattern=r'[\s\S]*', max_length=1000)] = Field(
        None, description='Description of a dataset'
    )
    datasetTitle: constr(pattern=r'.*\S.*', min_length=1, max_length=255) = Field(
        ..., description='Title for a given Dataset'
    )
    kind: Kind = Field(..., description='Dataset Kind')
    ownerInfo: Optional[OwnerInfo] = Field(
        None, description='A structure for Dataset owner info.'
    )
    permissionGroupParams: PermissionGroupParams = Field(
        ...,
        description='<p>Permission group parameters for Dataset permissions.</p> <p>Here is an example of how you could specify the <code>PermissionGroupParams</code>:</p> <p> <code> { "permissionGroupId": "0r6fCRtSTUk4XPfXQe3M0g", "datasetPermissions": [ {"permission": "ViewDatasetDetails"}, {"permission": "AddDatasetData"}, {"permission": "EditDatasetMetadata"}, {"permission": "DeleteDataset"} ] } </code> </p>',
    )
    schemaDefinition: Optional[SchemaDefinition1] = Field(
        None, description='A union of schema types.'
    )


class Datasetsv2DatasetIdPutRequest(BaseModel):
    alias: Optional[constr(pattern=r'^alias\/\S+', min_length=1, max_length=255)] = (
        Field(None, description='The unique resource identifier for a Dataset.')
    )
    clientToken: Optional[constr(pattern=r'.*\S.*', min_length=1, max_length=128)] = (
        Field(None, description='Idempotence Token for API operations')
    )
    datasetDescription: Optional[constr(pattern=r'[\s\S]*', max_length=1000)] = Field(
        None, description='Description of a dataset'
    )
    datasetTitle: constr(pattern=r'.*\S.*', min_length=1, max_length=255) = Field(
        ..., description='Title for a given Dataset'
    )
    kind: Kind = Field(..., description='Dataset Kind')
    schemaDefinition: Optional[SchemaDefinition1] = Field(
        None, description='A union of schema types.'
    )


class ChangesetSummary(BaseModel):
    activeFromTimestamp: Optional[TimestampEpoch] = None
    activeUntilTimestamp: Optional[TimestampEpoch] = None
    changeType: Optional[ChangeType] = None
    changesetArn: Optional[ChangesetArn] = None
    changesetId: Optional[ChangesetId] = None
    createTime: Optional[TimestampEpoch] = None
    datasetId: Optional[DatasetId] = None
    errorInfo: Optional[ChangesetErrorInfo] = None
    formatParams: Optional[FormatParams] = None
    sourceParams: Optional[SourceParams] = None
    status: Optional[IngestionStatus] = None
    updatedByChangesetId: Optional[ChangesetId] = None
    updatesChangesetId: Optional[ChangesetId] = None


class CreateChangesetRequest(BaseModel):
    changeType: ChangeType
    clientToken: Optional[ClientToken] = None
    formatParams: FormatParams
    sourceParams: SourceParams


class DataViewDestinationTypeParams(BaseModel):
    destinationType: DataViewDestinationType
    s3DestinationExportFileFormat: Optional[ExportFileFormat] = None
    s3DestinationExportFileFormatOptions: Optional[S3DestinationFormatOptions] = None


class DataViewSummary(BaseModel):
    asOfTimestamp: Optional[TimestampEpoch] = None
    autoUpdate: Optional[Boolean] = None
    createTime: Optional[TimestampEpoch] = None
    dataViewArn: Optional[DataViewArn] = None
    dataViewId: Optional[DataViewId] = None
    datasetId: Optional[DatasetId] = None
    destinationTypeProperties: Optional[DataViewDestinationTypeParams] = None
    errorInfo: Optional[DataViewErrorInfo] = None
    lastModifiedTime: Optional[TimestampEpoch] = None
    partitionColumns: Optional[PartitionColumnList] = None
    sortColumns: Optional[SortColumnList] = None
    status: Optional[DataViewStatus] = None


class Dataset(BaseModel):
    alias: Optional[AliasString] = None
    createTime: Optional[TimestampEpoch] = None
    datasetArn: Optional[DatasetArn] = None
    datasetDescription: Optional[DatasetDescription] = None
    datasetId: Optional[DatasetId] = None
    datasetTitle: Optional[DatasetTitle] = None
    kind: Optional[DatasetKind] = None
    lastModifiedTime: Optional[TimestampEpoch] = None
    ownerInfo: Optional[DatasetOwnerInfo] = None
    schemaDefinition: Optional[SchemaUnion] = None


class DatasetList(RootModel[List[Dataset]]):
    root: List[Dataset] = Field(..., description='List of Dataset structures')


class GetChangesetResponse(BaseModel):
    activeFromTimestamp: Optional[TimestampEpoch] = None
    activeUntilTimestamp: Optional[TimestampEpoch] = None
    changeType: Optional[ChangeType] = None
    changesetArn: Optional[ChangesetArn] = None
    changesetId: Optional[ChangesetId] = None
    createTime: Optional[TimestampEpoch] = None
    datasetId: Optional[DatasetId] = None
    errorInfo: Optional[ChangesetErrorInfo] = None
    formatParams: Optional[FormatParams] = None
    sourceParams: Optional[SourceParams] = None
    status: Optional[IngestionStatus] = None
    updatedByChangesetId: Optional[ChangesetId] = None
    updatesChangesetId: Optional[ChangesetId] = None


class GetDataViewResponse(BaseModel):
    asOfTimestamp: Optional[TimestampEpoch] = None
    autoUpdate: Optional[Boolean] = None
    createTime: Optional[TimestampEpoch] = None
    dataViewArn: Optional[DataViewArn] = None
    dataViewId: Optional[DataViewId] = None
    datasetId: Optional[DatasetId] = None
    destinationTypeParams: Optional[DataViewDestinationTypeParams] = None
    errorInfo: Optional[DataViewErrorInfo] = None
    lastModifiedTime: Optional[TimestampEpoch] = None
    partitionColumns: Optional[PartitionColumnList] = None
    sortColumns: Optional[SortColumnList] = None
    status: Optional[DataViewStatus] = None


class GetDatasetResponse(BaseModel):
    alias: Optional[AliasString] = None
    createTime: Optional[TimestampEpoch] = None
    datasetArn: Optional[DatasetArn] = None
    datasetDescription: Optional[DatasetDescription] = None
    datasetId: Optional[DatasetId] = None
    datasetTitle: Optional[DatasetTitle] = None
    kind: Optional[DatasetKind] = None
    lastModifiedTime: Optional[TimestampEpoch] = None
    schemaDefinition: Optional[SchemaUnion] = None
    status: Optional[DatasetStatus] = None


class GetPermissionGroupResponse(BaseModel):
    permissionGroup: Optional[PermissionGroup] = None


class ListDatasetsResponse(BaseModel):
    datasets: Optional[DatasetList] = None
    nextToken: Optional[PaginationToken] = None


class ListPermissionGroupsByUserResponse(BaseModel):
    nextToken: Optional[PaginationToken] = None
    permissionGroups: Optional[PermissionGroupByUserList] = None


class ListPermissionGroupsResponse(BaseModel):
    nextToken: Optional[PaginationToken] = None
    permissionGroups: Optional[PermissionGroupList] = None


class ListUsersByPermissionGroupResponse(BaseModel):
    nextToken: Optional[PaginationToken] = None
    users: Optional[UserByPermissionGroupList] = None


class ListUsersResponse(BaseModel):
    nextToken: Optional[PaginationToken] = None
    users: Optional[UserList] = None


class ChangesetList(RootModel[List[ChangesetSummary]]):
    root: List[ChangesetSummary] = Field(..., description='List of Changeset Summaries')


class CreateDataViewRequest(BaseModel):
    asOfTimestamp: Optional[TimestampEpoch] = None
    autoUpdate: Optional[Boolean] = None
    clientToken: Optional[ClientToken] = None
    destinationTypeParams: DataViewDestinationTypeParams
    partitionColumns: Optional[PartitionColumnList] = None
    sortColumns: Optional[SortColumnList] = None


class CreateDatasetRequest(BaseModel):
    alias: Optional[AliasString] = None
    clientToken: Optional[ClientToken] = None
    datasetDescription: Optional[DatasetDescription] = None
    datasetTitle: DatasetTitle
    kind: DatasetKind
    ownerInfo: Optional[DatasetOwnerInfo] = None
    permissionGroupParams: PermissionGroupParams
    schemaDefinition: Optional[SchemaUnion] = None


class DataViewList(RootModel[List[DataViewSummary]]):
    root: List[DataViewSummary] = Field(..., description='List of Data Views')


class ListChangesetsResponse(BaseModel):
    changesets: Optional[ChangesetList] = None
    nextToken: Optional[PaginationToken] = None


class ListDataViewsResponse(BaseModel):
    dataViews: Optional[DataViewList] = None
    nextToken: Optional[PaginationToken] = None
